import type { Handler } from "@netlify/functions";
import { GoogleGenAI, Modality } from "@google/genai";
import { getStore } from "@netlify/blobs"; // <-- IMPORT BLOBS

// Node.js method to convert image URL to base64
const imageUrlToBase64 = async (url: string): Promise<{ base64: string, mimeType: string }> => {
  const response = await fetch(url);
  if (!response.ok) { throw new Error(`Failed to fetch image: ${response.status}`); }
  const blob = await response.blob();
  if (blob.type === 'image/png' && blob.size < 20000) {
    throw new Error("404: No Street View imagery available.");
  }
  const arrayBuffer = await blob.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);
  const base64 = buffer.toString('base64');
  return { base64: base64, mimeType: blob.type };
};

const handler: Handler = async (event) => {
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: 'Method Not Allowed' };
  }

  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    console.error("[stylize-run] GEMINI_API_KEY is not set");
    return { statusCode: 500, body: JSON.stringify({ error: "GEMINI_API_KEY is not set" }) };
  }

  try {
    // 1. GET DATA FROM FRONTEND
    const { streetViewUrl, artStyle, jobId } = JSON.parse(event.body || '{}');
    if (!streetViewUrl || !artStyle || !jobId) {
      return { statusCode: 400, body: JSON.stringify({ error: "Missing streetViewUrl, artStyle, or jobId" }) };
    }
    
    const ai = new GoogleGenAI({ apiKey });
    const { base64: base64Image, mimeType } = await imageUrlToBase64(streetViewUrl);

    // 2. YOUR PROMPT (Unchanged)
    let styleDescription = '';
    switch (artStyle) {
      case 'Oil Painting':
        styleDescription = 'transform the result into a rich and textured oil painting. The style should feature visible, impasto brushstrokes and a deep color palette.';
        break;
      case 'Pencil Sketch':
        styleDescription = 'transform the result into a detailed pencil sketch. The style should be monochromatic, emphasizing lines, shading, and texture to create a hand-drawn, artistic feel.';
        break;
      default:
        styleDescription = 'transform the result into a vibrant and artistic watercolor painting. The style should be loose and expressive, with visible brushstrokes and color bleeds, typical of a real watercolor painting.';
        break;
    }
    const prompt = `
      Analyze the provided street view image...
      After cleaning the image, ${styleDescription} Ensure the final output is only the generated image itself, with no text or borders.
    `; // (I've truncated your prompt for brevity, use your full one)

    // 3. CALL GEMINI (Unchanged)
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts: [{ inlineData: { data: base64Image, mimeType } }, { text: prompt }] },
      config: { responseModalities: [Modality.IMAGE] },
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        const base64ImageBytes: string = part.inlineData.data;
        const generatedMimeType = part.inlineData.mimeType;
        const generatedUrl = `data:${generatedMimeType};base64,${base64ImageBytes}`;
        
        // 4. SAVE RESULT TO BLOB STORAGE
        const store = getStore("stylized-images");
        await store.setJSON(jobId, {
          status: "complete",
          generatedUrl: generatedUrl
        });
        
        // Background functions just need to return 200 to signal success
        return { statusCode: 200, body: "Job complete." };
      }
    }
    
    throw new Error("No image was generated by the API.");

  } catch (error) {
    console.error("Error in stylize-run function:", error);
    // If it fails, save the error message to the blob store
    const { jobId } = JSON.parse(event.body || '{}');
    if (jobId) {
      const store = getStore("stylized-images");
      await store.setJSON(jobId, {
        status: "error",
        message: error instanceof Error ? error.message : "Unknown server error"
      });
    }
    return {
      statusCode: 500,
      body: JSON.stringify({ error: error instanceof Error ? error.message : "Unknown server error" }),
    };
  }
};

export { handler };